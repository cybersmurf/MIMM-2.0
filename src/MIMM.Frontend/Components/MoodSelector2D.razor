@using Microsoft.AspNetCore.Components.Web

<MudStack Spacing="1">
    <MudText Typo="Typo.subtitle2">Mood (Russell 2D)</MudText>
    
    <svg width="@Size" height="@Size" 
         class="mood-selector-svg"
         role="slider"
         aria-label="Mood selector: valence (left/right) and arousal (up/down)"
         aria-valuemin="-1"
         aria-valuemax="1"
         aria-valuenow="@Valence.ToString("F2")"
         tabindex="0"
         @onpointerdown="OnSvgPointerDown"
         @onpointermove="OnSvgPointerMove"
         @onpointerup="StopDragging"
         @onpointerleave="StopDragging"
         @ontouchstart="OnSvgTouchStart"
         @ontouchmove="OnSvgTouchMove"
         @ontouchend="OnTouchEnd"
         @onkeydown="HandleKeyDown"
         style="cursor: crosshair; border-radius: 12px; overflow: hidden;">
        
        <!-- Background -->
        <defs>
            <radialGradient id="bgGradient" cx="50%" cy="50%">
                <stop offset="0%" style="stop-color:rgba(255,255,255,0.1);stop-opacity:1" />
                <stop offset="100%" style="stop-color:rgba(0,0,0,0.05);stop-opacity:1" />
            </radialGradient>
        </defs>
        <rect width="@Size" height="@Size" fill="url(#bgGradient)" />
        
        <!-- Grid lines -->
        @for (int i = 1; i <= 3; i++)
        {
            int x = (Size / 4) * i;
            int y = (Size / 4) * i;
            <line x1="@x" y1="0" x2="@x" y2="@Size" stroke="rgba(0,0,0,0.1)" stroke-width="1" />
            <line x1="0" y1="@y" x2="@Size" y2="@y" stroke="rgba(0,0,0,0.1)" stroke-width="1" />
        }
        
        <!-- Axis labels -->
        <text x="8" y="@(Size/2 + 4)" font-size="12" fill="rgba(0,0,0,0.6)">Negative</text>
        <text x="@(Size - 68)" y="@(Size/2 + 4)" font-size="12" fill="rgba(0,0,0,0.6)" text-anchor="end">Positive</text>
        <text x="@(Size/2)" y="16" font-size="12" fill="rgba(0,0,0,0.6)" text-anchor="middle">High arousal</text>
        <text x="@(Size/2)" y="@(Size - 8)" font-size="12" fill="rgba(0,0,0,0.6)" text-anchor="middle">Low arousal</text>
        
        <!-- Cursor circle -->
        <circle cx="@CursorX" cy="@CursorY" r="10" fill="white" stroke="rgb(59,130,246)" stroke-width="3" 
                style="pointer-events: none; filter: drop-shadow(0 0 6px rgba(0,0,0,0.12));" />
        
        <!-- Mood label background -->
        <rect x="8" y="8" width="200" height="28" rx="6" fill="rgb(59,130,246)" opacity="0.9" />
        <text x="18" y="28" font-size="14" font-weight="bold" fill="white" font-family="Roboto, sans-serif">
            @MoodLabel (V @Valence.ToString("F2"), A @Arousal.ToString("F2"))
        </text>
    </svg>
    
    <MudText Typo="Typo.caption" Color="Color.Secondary">
        Click or drag to set mood. Use arrow keys: ← → for valence, ↑ ↓ for arousal. Center is neutral; top-right is happy/energized; bottom-left is sad/calm.
    </MudText>
</MudStack>

@code {
    [Parameter]
    public double Valence { get; set; }

    [Parameter]
    public EventCallback<double> ValenceChanged { get; set; }

    [Parameter]
    public double Arousal { get; set; }

    [Parameter]
    public EventCallback<double> ArousalChanged { get; set; }

    [Parameter]
    public EventCallback<(double Valence, double Arousal)> OnChanged { get; set; }

    [Parameter]
    public int Size { get; set; } = 320;

    private bool _isDragging;

    // Direct SVG coordinates (px)
    private double CursorX => ((Valence + 1) / 2) * Size;
    private double CursorY => ((1 - Arousal) / 2) * Size;

    private async Task OnSvgPointerDown(PointerEventArgs e)
    {
        _isDragging = true;
        await UpdateFromSvgPointerAsync(e);
    }

    private async Task OnSvgPointerMove(PointerEventArgs e)
    {
        if (!_isDragging)
            return;

        await UpdateFromSvgPointerAsync(e);
    }

    private void StopDragging(PointerEventArgs _)
    {
        _isDragging = false;
    }

    private async Task UpdateFromSvgPointerAsync(PointerEventArgs e)
    {
        // Blazor SVG events already give us correct offsetX/Y relative to SVG
        var x = Math.Clamp(e.OffsetX, 0, Size);
        var y = Math.Clamp(e.OffsetY, 0, Size);

        var valence = Math.Clamp((x / Size) * 2 - 1, -1, 1);
        var arousal = Math.Clamp(1 - (y / Size) * 2, -1, 1);

        await SetValuesAsync(valence, arousal);
    }

    private async Task OnSvgTouchStart(TouchEventArgs e)
    {
        if (e.Touches.Length > 0)
        {
            _isDragging = true;
            await UpdateFromTouchAsync(e.Touches[0]);
        }
    }

    private async Task OnSvgTouchMove(TouchEventArgs e)
    {
        if (!_isDragging || e.Touches.Length == 0)
            return;

        await UpdateFromTouchAsync(e.Touches[0]);
    }

    private void OnTouchEnd(TouchEventArgs e)
    {
        _isDragging = false;
    }

    private async Task UpdateFromTouchAsync(TouchPoint touch)
    {
        // For touch, we need to calculate relative position
        // This is a simplified approach - in production you'd want JS interop for getBoundingClientRect
        var x = Math.Clamp(touch.ClientX, 0, Size);
        var y = Math.Clamp(touch.ClientY, 0, Size);

        var valence = Math.Clamp((x / Size) * 2 - 1, -1, 1);
        var arousal = Math.Clamp(1 - (y / Size) * 2, -1, 1);

        await SetValuesAsync(valence, arousal);
    }

    // Keyboard navigation (arrow keys for accessibility)
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        const double step = 0.1;
        var newValence = Valence;
        var newArousal = Arousal;
        var handled = false;

        switch (e.Key)
        {
            case "ArrowLeft":
                newValence = Math.Clamp(Valence - step, -1, 1);
                handled = true;
                break;
            case "ArrowRight":
                newValence = Math.Clamp(Valence + step, -1, 1);
                handled = true;
                break;
            case "ArrowUp":
                newArousal = Math.Clamp(Arousal + step, -1, 1);
                handled = true;
                break;
            case "ArrowDown":
                newArousal = Math.Clamp(Arousal - step, -1, 1);
                handled = true;
                break;
        }

        if (handled)
        {
            await SetValuesAsync(newValence, newArousal);
        }
    }

    private async Task SetValuesAsync(double valence, double arousal)
    {
        var valenceChanged = !valence.Equals(Valence);
        var arousalChanged = !arousal.Equals(Arousal);

        if (valenceChanged)
        {
            Valence = valence;
            if (ValenceChanged.HasDelegate)
            {
                await ValenceChanged.InvokeAsync(valence);
            }
        }

        if (arousalChanged)
        {
            Arousal = arousal;
            if (ArousalChanged.HasDelegate)
            {
                await ArousalChanged.InvokeAsync(arousal);
            }
        }

        if (OnChanged.HasDelegate && (valenceChanged || arousalChanged))
        {
            await OnChanged.InvokeAsync((valence, arousal));
        }
    }

    private string MoodLabel => (Valence, Arousal) switch
    {
        (> 0.3, > 0.3) => "Excited / Happy",
        (> 0.3, < -0.3) => "Calm / Content",
        (< -0.3, > 0.3) => "Tense / Frustrated",
        (< -0.3, < -0.3) => "Low / Down",
        _ => "Neutral"
    };
}

