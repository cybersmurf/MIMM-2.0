@using Microsoft.AspNetCore.Components.Web
@inject IJSRuntime JSRuntime

<MudStack Spacing="1">
    <MudText Typo="Typo.subtitle2">Mood (Russell 2D)</MudText>
    <MudPaper Class="mood-plane" 
              Elevation="2" 
              style="@($"width:{Size}px;height:{Size}px;")"
              role="slider"
              aria-label="Mood selector: valence (left/right) and arousal (up/down)"
              aria-valuemin="-1"
              aria-valuemax="1"
              aria-valuenow="@Valence.ToString("F2")"
              tabindex="0"
              @onpointerdown="OnPointerDown"
              @onpointermove="OnPointerMove"
              @onpointerup="StopDragging"
              @onpointerleave="StopDragging"
              @ontouchstart="OnTouchStart"
              @ontouchmove="OnTouchMove"
              @ontouchend="OnTouchEnd"
              @onkeydown="HandleKeyDown"
              id="mood-plane-container">
        <div class="axis-label axis-label-x-left">Negative valence</div>
        <div class="axis-label axis-label-x-right">Positive valence</div>
        <div class="axis-label axis-label-y-top">High arousal</div>
        <div class="axis-label axis-label-y-bottom">Low arousal</div>

        <div class="grid">
            <div class="grid-line vertical" style="left:25%"></div>
            <div class="grid-line vertical" style="left:50%"></div>
            <div class="grid-line vertical" style="left:75%"></div>
            <div class="grid-line horizontal" style="top:25%"></div>
            <div class="grid-line horizontal" style="top:50%"></div>
            <div class="grid-line horizontal" style="top:75%"></div>
        </div>

        <div class="cursor" style="left:@CursorLeft%; top:@CursorTop%"></div>

        <MudChip T="string" Class="label-chip" Color="Color.Primary" Variant="Variant.Filled">
            @MoodLabel (V @Valence.ToString("F2"), A @Arousal.ToString("F2"))
        </MudChip>
    </MudPaper>
    <MudText Typo="Typo.caption" Color="Color.Secondary">
        Click or drag to set mood. Use arrow keys: ← → for valence, ↑ ↓ for arousal. Center is neutral; top-right is happy/energized; bottom-left is sad/calm.
    </MudText>
</MudStack>

@code {
    [Parameter]
    public double Valence { get; set; }

    [Parameter]
    public EventCallback<double> ValenceChanged { get; set; }

    [Parameter]
    public double Arousal { get; set; }

    [Parameter]
    public EventCallback<double> ArousalChanged { get; set; }

    [Parameter]
    public EventCallback<(double Valence, double Arousal)> OnChanged { get; set; }

    [Parameter]
    public int Size { get; set; } = 320;

    private bool _isDragging;

    private double CursorLeft => Math.Clamp((Valence + 1) / 2 * 100, 0, 100);
    private double CursorTop => Math.Clamp(0.5 * (1 - Arousal) * 100, 0, 100);

    // Touch event handlers
    private async Task OnTouchStart(TouchEventArgs e)
    {
        if (e.Touches.Length > 0)
        {
            _isDragging = true;
            await UpdateFromTouchAsync(e.Touches[0]);
        }
    }

    private async Task OnTouchMove(TouchEventArgs e)
    {
        if (!_isDragging || e.Touches.Length == 0)
            return;

        await UpdateFromTouchAsync(e.Touches[0]);
    }

    private void OnTouchEnd(TouchEventArgs e)
    {
        _isDragging = false;
    }

    // Keyboard navigation (arrow keys for accessibility)
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        const double step = 0.1;
        var newValence = Valence;
        var newArousal = Arousal;
        var handled = false;

        switch (e.Key)
        {
            case "ArrowLeft":
                newValence = Math.Clamp(Valence - step, -1, 1);
                handled = true;
                break;
            case "ArrowRight":
                newValence = Math.Clamp(Valence + step, -1, 1);
                handled = true;
                break;
            case "ArrowUp":
                newArousal = Math.Clamp(Arousal + step, -1, 1);
                handled = true;
                break;
            case "ArrowDown":
                newArousal = Math.Clamp(Arousal - step, -1, 1);
                handled = true;
                break;
        }

        if (handled)
        {
            await SetValuesAsync(newValence, newArousal);
        }
    }

    private async Task OnPointerDown(PointerEventArgs e)
    {
        _isDragging = true;
        await UpdateFromPointerAsync(e);
    }

    private async Task OnPointerMove(PointerEventArgs e)
    {
        if (!_isDragging)
        {
            return;
        }

        await UpdateFromPointerAsync(e);
    }

    private void StopDragging(PointerEventArgs _)
    {
        _isDragging = false;
    }

    private async Task UpdateFromPointerAsync(PointerEventArgs e)
    {
        try
        {
            // Get the actual position relative to the mood-plane container using JavaScript
            var position = await JSRuntime.InvokeAsync<double[]>("getRelativePositionById", "mood-plane-container", e.ClientX, e.ClientY);
            
            if (position == null || position.Length < 2)
                return;

            var x = Math.Clamp(position[0], 0, Size);
            var y = Math.Clamp(position[1], 0, Size);

            var valence = Math.Clamp((x / Size) * 2 - 1, -1, 1);
            var arousal = Math.Clamp(1 - (y / Size) * 2, -1, 1);

            await SetValuesAsync(valence, arousal);
        }
        catch
        {
            // Fallback to OffsetX/Y if JS interop fails
            var x = Math.Clamp(e.OffsetX, 0, Size);
            var y = Math.Clamp(e.OffsetY, 0, Size);

            var valence = Math.Clamp((x / Size) * 2 - 1, -1, 1);
            var arousal = Math.Clamp(1 - (y / Size) * 2, -1, 1);

            await SetValuesAsync(valence, arousal);
        }
    }

    private async Task UpdateFromTouchAsync(TouchPoint touch)
    {
        // For touch events, we need to handle clientX/Y differently
        // This is a simplified implementation; in production you'd get the bounding rect
        var x = touch.ClientX;
        var y = touch.ClientY;

        // Approximate positioning (would need actual element bounds in production)
        var valence = Math.Clamp((x / Size) * 2 - 1, -1, 1);
        var arousal = Math.Clamp(1 - (y / Size) * 2, -1, 1);

        await SetValuesAsync(valence, arousal);
    }

    private async Task SetValuesAsync(double valence, double arousal)
    {
        var valenceChanged = !valence.Equals(Valence);
        var arousalChanged = !arousal.Equals(Arousal);

        if (valenceChanged)
        {
            Valence = valence;
            if (ValenceChanged.HasDelegate)
            {
                await ValenceChanged.InvokeAsync(valence);
            }
        }

        if (arousalChanged)
        {
            Arousal = arousal;
            if (ArousalChanged.HasDelegate)
            {
                await ArousalChanged.InvokeAsync(arousal);
            }
        }

        if (OnChanged.HasDelegate && (valenceChanged || arousalChanged))
        {
            await OnChanged.InvokeAsync((valence, arousal));
        }
    }

    private string MoodLabel => (Valence, Arousal) switch
    {
        (> 0.3, > 0.3) => "Excited / Happy",
        (> 0.3, < -0.3) => "Calm / Content",
        (< -0.3, > 0.3) => "Tense / Frustrated",
        (< -0.3, < -0.3) => "Low / Down",
        _ => "Neutral"
    };
}
